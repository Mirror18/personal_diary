# personal_diary

完全属于自己的私密日记网站。

当前已经完成后端框架的搭建，并且完善了所需加入的依赖。

当前加入的有。

* spring boot mvc
* spring boot security
* mybatis
* redis
* redisson
* mapstruct
* jackson
* aliyun.sdk

这些是这个项目所用的，当然，一个简单的框架，这几个就足够用了

* spring boot mvc
* mybatis

那么跟随我的脚步前进吧。

首先是整体的分布

![image-20241007012156706](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410070121900.png)

解释下作用，parent内部仅有pom.xml文件，当然后续会接入 docker 文档，用于创建docker容器，但是现在我不太会编写。这个pom文件主要编写的是所需要以来的三方库，整个项目的三方库。然后项目中就可以不用写版本，但是我觉得不如直接写property属性即可。当然这个三方库的依赖简直是一言难尽，可以说这里查浏览器的次数最多。

然后是common模块，这个模块下![image-20241007012626418](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410070126557.png)h很好理解，config是用于注入三方库的bean的，因为三方库的内容上不会写@@Component的，表示这玩意儿需要ioc进行实例化，那么只能自己注入三方bean。里面的东西后续再说。

然后是properties，这里面都是bean，什么意思，就是要注入的applicaiton.yml文件中的配置信息，原先是用@Value来进行注入字段，现在直接当作一个bean来注入，可以说更人性化了吧。

constant，就是常量，因为为了学习一些更多的写法，所以是有enum，也有字段。当然要说为什么有这两种，其实更多的意思是在于写接口的时候，限制不限制要传入的类型。毕竟虽然是有order，但是一般也用不到。

然后就是exception，就是异常，也包括全局异常，什么意思，就是返回自定义错误类型，可以包含更多的信息。当然，globalexception错误类型除外，比起说是自定义错误类型，这玩意儿的作用是将错误信息以更规范的方式进行响应，返回到调用前端，而不是在后端查看信息。

result。名字就是作用，用于规范饭hi类型，本来这玩意儿想放到pojo，也就是传递信息用的，但是在全局异常处理的时候，用了这玩意儿包裹，所以就会出现循环依赖，只能放到这里了。

service，其实放在这里也不准确，不过暂时没有挪动的想法，主要是authfilter放这里比较合适，因为是添加过滤器，会对请求进行一个检测，看是否进行预处理。至于另外两个，就是附带的。

util，自己写的方法存放地点。用于一些数据的处理，或者获取一些当前信息所用。



![image-20241007014544424](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410070145450.png)

pojo模块就相对来说简单很多。里面全都是bean，用于对应数据结构，只有一个转换用的。

convertor，这个就是转换器，也就是mapstruct唯一使用的地方。里面的内容很简单，都是将一种Java类转换成另外一种Java类。

dto，用于service调用的时候，传递的数据类型。主要就是在后端中传递。

entity，是表结构，调用jdbc或者mabtis查询数据库的时候，有表可以照应。

form,就是前端请求的表单类型。按理来说也是需要转换的，不过这一步已经由默认的jackson给代替了。只需要给类型即可。

result，实话说应该和entity进行一个合并，因为都是调用service中间需要返回的数据，但是和entity不同的是，没有数据库的表进行对应，单独分出来，更好的后续创表操作。

vo，也是返回类型，或者说响应类型。但是这个是要返回给前端的，具体的表现就是，一般用在controller中，进行相应给前端。

总的来说，pojo的设计很简单，只需要考虑两件事，前端返回的数据类型，和后端返回给前端的响应类型。这些定义都是人为划分的，实话说用的时候界限不是那么明显，毕竟除了响应和请求。其他的都可以认为是dto，在service中传递数据。

![image-20241007020030328](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410070200368.png)

这个模块也是想了半天取什么名字为好。这里表明是对数据库进行操作。而且这里还进行了复杂装配，什么意思呢，

如果我们单纯的用mabtis，其实就两文件夹，一个mapper，里面是接口，用于表明什么操作，对应需要传入的接口，可以通过注解传入sql语法。

然后是存放在resource中的mapper文件夹，里面是xml配置，操作哪个表，传入类型，返回类型，或者单独的返回类是那个，标注好，然后再写sql语法。这样就完成了mabaits的设置。后续server调用的时候只需要调用接口即可。

但是也发现了不对劲的事，那就是这吊毛玩意儿忒没自由度了，任何一个MySQL的操作都需要单独写一个xml配置，最少也要写个接口。于是就出现了mbatis-plus。还有这个玩意儿，可以理解为生成器。就是相对来说操作也复杂了。

这玩意的好处就是在sever中可以随意写sql语法。只需要使用包装类即可。现在这里面的内容还算简单，因为还没有写插件。

core，顾名思义，就是这个生成器的核心配置，有需要传入的类型，也有返回类型，其中还要有数据库字段。

起到查询数据库的作用的是wrapper，也就是包装类，也分为两种，

mabtisWrapper，就是写自定义语法的时候所用。

然后就是正常的mapper，这些都是接口，需要xml来进行配置。

![image-20241007022056728](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410070220774.png)

server-api。如果抛弃掉启动类，其实就是一个controller，用于匹配URL路径，调用哪个方法。

可以说这里是最关键的，也是不需要怎么写的，这里只需要配置URL路径，然后是传入的请求类型，返回的类型，也就是form和vo这两种类型，在写一下调用的是那个方法，service。即可。当然这里的resource里面是要包含所需的配置信息。也就是application.yml还有输入日志的配置。

![image-20241007022447148](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410070224180.png)

这里比较复杂，复杂指的是写的东西。结构很简单，接口+实现类即可。也就是逻辑处理，重中之重。当然这里也会讲如何编写的。只不过现在先讲整体的项目构造。

